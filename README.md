
# YourStore ## https://your-store-one.vercel.app/

## Проэкт разработан в учебных целях! 

## Используемые технологи: NextJS, React, ReduxToolkit, TypeScript, Sass(+module), firebase, API [https://fakestoreapi.com/]

1. ***База NextJS.*** 
- Роутинг, получение ***props*** и ***path***
	при помощи ***getStaticProps*** и ***getStaticPaths***соответственно.
- **Dynamic paths** Использованны для получения страниц:
- **ProductsDetails** - использовал ***ID*** из полученного API
- **UserProfile** - использовал ***email*** Пользователя обрезанный до знака '@'

2. ***React*** - Лежит в основе NextJS. Использовал все базовые фичи.
					
3. ***Redux-Toolkit.js***
	1. **createAsyncThunk** - использовал для получения данных с ***API*** 
с последующей обработкой по мере необходимой логики, c дальнейшим добавление в **state**
c помощью ***extraReducers***. Все это делалось Асинхронно с целью набить нужные навыки:
	- Получение и отображение всех **Products**
	- Поиск **Products**
	- Удаление товаров из **Cart**
	- Получение **Categories**
	2. По классике все разбито на ***Slice*** 
	- **categoriesSlice** action **createAsyncThunk** на получение, и один **extraReducer**
	для добавления в state
	- **productsSlice** тут то и происходит вся "Вкуснятина" 
		- ***getAllProducts*** Получить, добавить в state on fulfilled
		- ***getSearchedProduct*** аргументом получаем value для поиска подстроки в строке, 
		получаем все **Products** и фильтруем.
		далее в **extraReducer** на fulfilled добавляем нужные **Products**
		- ***addProductToCart*** Получаем **id** в параметры, фильтруем по **id** добавляем в ***Cart***,
		!Не забываем сделать проверку при добавлении в **state** на наличие товаров в **Cart**
		- ***removeProduct*** Получаем **id** в параметры, фильтруем по **id** удаляем нужный. Обновляем **State**
	  - Остальная логика завязанная на стандартных **Actions** думаю без описания понятно за что они отвечают
		[ addCount, deleteCount, increasePrice, decreasePrice, decreasePriceWithRemove, clearCart ]
4. ***TypeScript***
-Типизация данных полученных с API отдельно в папочке types, там же и интерфейсы связанные с авторизацией Users	
-Redux полностью типизирован включая useDispatch и useSelector hooks
-Props по класике создавал interface до экспорта компонента, единственно extends от DetailedHTMLProps (в зависимости от HTML элемента который возвращал)
для удобства в папочке types создал файл detailsProps.ts в котором описал типы возможных конфигураций.
-Что касательно аргументов функций проблемных мест не было, event типизирован в React просто указываем нужный эвент, state в Redux так же из коробки легко типизирутся
5. ***Sass + css.modules*** - тут все понятно, и по классике. Так же использовал библиотеку **classnames**, очень удобно задавать динамические классы зависимые от
состояний local или global state, ну или context, info из объекта useRouter(), или даже из кастомного хука useAuth()
6. ***firebase*** Впервые попробовал, разобрался с настройками, ключами (правда ключи пришлось в открытую указать ибо файл env.local nextJS в деплой версии отказался видеть, пытался найти где они там в настройках проекта задаются, так и не допер), остальные настройки очень примитивны, для хранения инфо о users используется 
Redux-store. Но обратной связи нет, то есть если обновить app то с сервера firebase users не придут. Но в базе они есть и при попытке снова залогинится по указанным 
в регистрации параметрам, вас без проблемм залогинит. 
7. Сделан adaptive and base-accessability
8. Добавил ***Form validation*** для компонента form (сущности loginForm и registerForm) Создал два хука **useValue** в котором происходит хранение value импутов
а так же установка значения из поля e.target.value на событии onChange, на onBlur навесил смену стейта isDurty для того чтобы отследить тот момент когда пользователь покинет поле инпута. Ну а в хуке useValidate проводил непосредственно проверки в конструкции switch/case по кейсам isEmty(проверка на пустоту) isEmail(регуляркой брал нужное значение для мейла и функцией test чекал на совпадение переданный value из input). Ну и minLenght для проверки минимального колличества символов в пароле.
В теле кейсов устанавливал значения соответствующих полей state для каждого. Так же стоит отметить что делать это нужно внутри useEffect, со значением value в массиве зависимостей. Ну и исходя из все этих проверок вешал необходимое сообщение при возникновении любой из ошибок, тут не заморачивался сделал одно сообщение которое просто говорит о не валидности input ну и disabled на button тоже присутствует. 
p.s Так же создание этих хуков позволило избавится от ненужных локальных стейтов в самом компоненте Form, и информация для передачи в redux-store и последущей отпркавки на сервер firebase теперь берется из хука useValue. 
p.s+p.s Изначально пробовал работать с библиотекой react-hook-form, но по какой то причине при навешивании {...register('name)} на кастомный компонент input. В полученной date получал пустой массив вместо пары ключ-значение, так же не сработал и перенос всей логики связанной с useForm() непосредственно в input (c последующей динамической передачей поля name из компонента Form, эффект был тот же, получаемое значение было undefined. Хотя при тесте на отдельно, специально созданном компоненте, все работало как надо, так и не разобрался во всей этой магии, офф документация не помогла =(
 - Доделал валидацию компонента **PaymentForm** проверка на  номер телефона regexpo как и на номера банковских карт, даже на смс код прикрутил regexp на 4 цыфры
 9. Подключил ***framer-motion*** Сделал loyout animation на появления страниц products, electronics, jewelery, men's, women's. Так же последовательное появления жлементов на страницу DetailsPage с разным delay по ключу custom. Так же организовал появления списка в Cart по item красиво сползают по одному. 
10. Добавил информацию о пользователе в localStorage, теперь при ресете страницы пользователь не разлогинится пока не нажмет кнопку logOut,

# Выводы
Доволен очень, как для первого самостоятельного проекта, без копипастов из уроков и видосов, очень даже ничего получилось. Не плохо разобрался в ***redux-toolkit***
подкачал ***TypeScript***, ну и главное ради чего затевалось, углубился в ***NextJS*** с его ssg / ssr rendering, dynamic paths, ну и удобной на самом деле, навигацией. ***React*** Так же становится проще для понимания, что приятно. Проникся в азы custom form-validation, даже по мучал **react-hooks-form**.
Разобрался с **framer-motion** на уровне layout и custom передаваемых в качестве аргумента в функции variants. LocalStorage в NextJS не так то прост как оказалось, из за специфике SSR next ничего не знает о локальном хранилище браузера, ибо данные он готовит на сервере, а следовательно взять и использовать их он не может, потому есть несколько решений обновлять и брать данные из localeStorage уже на стороне клиента, я использовал useEffect для изятия данных(p/s Что то не понятное творилось с JSON строкой, постоянно добавлялись какие то лишние символы '/' И stringify делался дважды при добавлении в localeStorage. С этой мистикой так и не разобрался, просто сделал жва вхоженных JSON.parse(JSON.parse(data))  Вот только так все заработало, интернеты по поводу сего бага ничего не сказали, но работает =).)
 Проэкт еще буду совершенствовать, на очереди осуществить чтобы пользователь не разлогинивался при ребуте страницы. 

#TODO 
~~Буду делать полную валидацию своих login, register,payment forms.~~
~~Так же ***Framer Motion*** поучусь добавлять базовые анимации.~~
~~Нужно что бы пользователь не разлогинивался при ребуте страницы, пока не знаю как, localeStorage или делать get запрос к farebase~~
~~Запихнуть данные из Cart в localeStorage~~
Запихнуть данные из Profile в localeStorage

p.s Орфография может страдать =) 

